## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2202`

#### Выполнил: `Ратникова Аглая Климовна`

#### Вариант: `20`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи
>1. Считывает с консоли число N, затем N целых чисел и заполняет
>массив размером N.
>2. Размещает числа в массиве таким образом, чтобы числа, являющиеся числами Фибоначчи, находились в начале массива в порядке
>возрастания, а остальные числа — в конце массива в порядке убывания. Число является числом Фибоначчи, если оно присутствует
>в последовательности Фибоначчи.
>3. Находит и выводит количество чисел Фибоначчи в массиве.
>4. Выводит элементы массива, заменяя числа Фибоначчи на порядковый номер в последовательности, а остальные числа — на −1.
>5. Заменяет каждое число в массиве на сумму его чётных цифр и
>выводит полученный массив.

Даны 5 задач.
1. Задать массив из чисел
2. Сортировка массива так, что сначала идут числа фибоначчи в порядке возрастания, после остальные в порядке убывания.
а)вычисления всех возможных чисел фибоначчи, которые только могут появиться в массиве(создания отдельного массива-последовательности фибоначчи последнее число которого не превышает максимальное значение )
б) Запоминаем, какие под каким индексом в изначальном массиве находятся числа фибоначчи.
в) Записываем числа Фибоначчи и остальные в два массива, сортирурую по возрастанию и убыванию соответственно и записываю обратно в изначальный массив.
3. Считаю количество чисел фибоначчи
4. Заменяю фибоначчи на индекс в последовательности, остальное на -1.
5. ПЗаменяю каждое число на сумму четных цифр.
### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать целое натуральное число или 0 N, тк это количество чисел. Далее программа считывает N целых чисел.

|             | Тип                | min значение    | max значение   |
|-------------|--------------------|-----------------|----------------|
| N (Число 1) | Вещественное число |        1        | 10<sup>9</sup> |
| ост N чисел | Вещественное число | -10<sup>9</sup> | 10<sup>9</sup> |

#### Данные на выход

Т.к. программа должна вывести несколько вариантов изначального массива и количество чисел Фибоначчи в нем, то на выход мы получаем только целые числа(в случае с количеством чисел, неотрицательные).

|                      | Тип                                | min значение | max значение   |
|----------------------|------------------------------------|--------------|----------------|
| количество чисел фиб | Вещественное неотрицательное число | 0            | 10<sup>9</sup> |
|       ост числа      |         Вещественное число         | 0            | 10<sup>9</sup> |

### 3. Выбор структуры данных

Программа получает N+1 вещественных чисел, поэтому выбираю тип Int.

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N (Число 1) | `x`                 |    `int`     |
| ост N чисел |  -                  |    `int`     | 



### 4. Алгоритм

#### Алгоритм выполнения программы:

1. Считываю N и создаю массив из N чисел с клавиатуры.
2. Генерирую последовательность фибоначчи до максимального из основного массива(нахожу перебором). Если максимум <0, то массив будет состоять из одного нулевого элемента
3. Создаю массив из 



### 5. Программа

```java
import java.util.Scanner;
import java.io.PrintStream;
public class fib {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {

        // считываем n
        int n = in.nextInt();

        // создаем массив
        int[] a = new int[n];

        // определим максимальное значение
        int maxArr = 0;
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
            if (a[i] > maxArr) {
                maxArr = a[i];
            }
        }

        // создаем массив из чисел фибоначчи до m
        int[] f = fibGen(maxArr);

        // запомним, какие из a являются фибоначчи
        boolean[] boolFib = new boolean[n];
        for (int i = 0; i < n; i++) {
            boolFib[i] = fibCheck(a[i], f);
        }

        // считаем сколько чисел фибоначчи
        int fibCount = 0;
        for (boolean y : boolFib) {
            if (y) fibCount++;
        }

        // создаем два массива: для фибоначчи и для остальных
        int[] aFib = new int[fibCount];
        int[] aOth = new int[n - fibCount];

        int aFibIndex = 0;  // индекс для фибоначчи
        int aOthIndex = 0;  // индекс для остальных
        for (int i = 0; i < n; i++) {
            if (boolFib[i]) {
                aFib[aFibIndex++] = a[i];
            } else {
                aOth[aOthIndex++] = a[i];
            }
        }

        // сортируем числа фибоначчи по возрастанию, а остальные по убыванию
        bublMax(aFib);
        bublMin(aOth);

        // собираем в изначальный массив
        int p = 0;
        for (int i : aFib) {
            a[p++] = i;
        }
        for (int i : aOth) {
            a[p++] = i;
        }

        // выводим результат
        for (int x : a) {
            out.print(x + " ");
        }
        out.println();
        out.println(fibCount);
        // выводим, заменяя фибоначчи на индекс, остальное на -1
        for (int x : a) {
            int idx = getIndex(x, f);
            if (idx != -1) {
                out.print(idx + " ");
            } else {
                out.print(-1 + " ");
            }
        }
        out.println();
        // заменяем каждое число на сумму чётных цифр
        for (int i = 0; i < n; i++) {
            a[i] = evenCount(a[i]);
        }

        // выводим результат
        for (int x : a) {
            out.print(x + " ");
        }
    }

    // генерим фибоначчи до max
    private static int[] fibGen(int x) {
        // если максимум меньше 1, вернем массив с одним значением
        if (x < 1) {
            return new int[]{0};
        }

        // начальные члены
        int f1 = 0, f2 = 1;

        // временный массив
        int[] tmp = new int[x + 2];
        int c = 0;
        tmp[c++] = f1;
        tmp[c++] = f2;

        // генерим пока не превысим x
        while (true) {
            int f3 = f1 + f2;
            if (f3 > x) break;
            tmp[c++] = f3;
            f1 = f2;
            f2 = f3;
        }

        // формируем итог
        int[] r = new int[c];
        for (int i = 0; i < c; i++) {
            r[i] = tmp[i];
        }
        return r;
    }

    // проверяем, является ли число фибоначчи
    private static boolean fibCheck(int x, int[] f) {
        for (int y : f) {
            if (y == x) {
                return true;
            }
            if (y > x) {
                return false;
            }
        }
        return false;
    }

    // пузырьковая сортировка по возрастанию
    private static void bublMax(int[] q) {
        for (int i = 0; i < q.length - 1; i++) {
            for (int j = 0; j < q.length - 1 - i; j++) {
                if (q[j] > q[j + 1]) {
                    int tmp = q[j];
                    q[j] = q[j + 1];
                    q[j + 1] = tmp;
                }
            }
        }
    }

    // пузырьковая сортировка по убыванию
    private static void bublMin(int[] q) {
        for (int i = 0; i < q.length - 1; i++) {
            for (int j = 0; j < q.length - 1 - i; j++) {
                if (q[j] < q[j + 1]) {
                    int tmp = q[j];
                    q[j] = q[j + 1];
                    q[j + 1] = tmp;
                }
            }
        }
    }
    // получаем индекс числа в ряду фибоначчи
    private static int getIndex(int x, int[] f) {
        for (int i = 0; i < f.length; i++) {
            if (f[i] == x) {
                return i;
            }
            if (f[i] > x) {
                return -1;
            }
        }
        return -1;
    }
    //считаем сумму четных цифр
    private static int evenCount(int x) {
        int sum = 0;
        // пока число не закончилось
        while (x > 0) {
            int d = x % 10;
            if (d % 2 == 0) {
                sum += d;
            }
            x /= 10;
        }
        return sum;
    }
}
```

### 6. Анализ правильности решения


1. Тест :

    - **Input**:
        ```
        6
        2 10 13 13 21 8 4 
        ```

    - **Output**:
        ```
        2 8 13 13 21 10
        5
        3 6 7 7 8 -1
        2 8 0 0 2 0 
        ```

2. Тест на ограничения:

    - **Input**:
        ```
        1
        0
        ```

    - **Output**:
        ```
        0
        1
        0
        0 
        ```


