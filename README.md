## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2202`

#### Выполнил: `Ратникова Аглая Климовна`

#### Вариант: `20`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Даны 5 задач.
> 1. Задать массив из чисел
> 2. Сортировка массива так, что сначала идут числа фибоначчи в порядке возрастания, после остальные в порядке убывания.
> а)вычисления всех возможных чисел фибоначчи, которые только могут появиться в массиве(создания отдельного массива-последовательности фибоначчи последнее число которого не превышает максимальное значение )
>
### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать целое натуральное число или 0 N, тк это количество чисел. Далее программа считывает N целых чисел.

|             | Тип                | min значение    | max значение   |
|-------------|--------------------|-----------------|----------------|
| N (Число 1) | Вещественное число |        1        | 10<sup>9</sup> |
| ост N чисел | Вещественное число | -10<sup>9</sup> | 10<sup>9</sup> |

#### Данные на выход

Т.к. программа должна вывести несколько вариантов изначального массива и количество чисел Фибоначчи в нем, то на выход мы получаем только целые числа(в случае с количеством чисел, неотрицательные).

|                      | Тип                                | min значение | max значение   |
|----------------------|------------------------------------|--------------|----------------|
| количество чисел фиб | Вещественное неотрицательное число | 0            | 10<sup>9</sup> |
|       ост числа      |         Вещественное число         | 0            | 10<sup>9</sup> |

### 3. Выбор структуры данных

Программа получает N+1 вещественных чисел, поэтому выбираю тип Int.

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N (Число 1) | `x`                 |    `int`     |
| ост N чисел |  -                  |    `int`     | 



### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два вещественных числа, обозначенные как `x` и `y`.

2. **Сравнение чисел:**  
   Программа сравнивает значения `x` и `y`. Если `x` больше или равно `y`, программа переходит к следующему шагу для
   работы с `x`. Если `y` больше, программа выполняет действия для работы с `y`.

3. **Проверка знака для выбранного числа:**
    - Если было выбрано число `x` (так как оно больше или равно `y`), проверяется, положительное оно или отрицательное.
      Если `x` положительное, оно выводится на экран. Если отрицательное, выводится его модуль (т.е. противоположное
      по знаку значение).
    - Если было выбрано число `y` (поскольку оно больше `x`), выполняется аналогичная проверка. Если `y` положительное,
      оно выводится на экран. Если отрицательное, выводится его модуль.

4. **Вывод результата:**  
   На экран выводится либо большее из чисел, либо его модуль, если это число отрицательное.



### 5. Программа

```java
import java.util.Scanner;
import java.io.PrintStream;
public class fib {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {

        // считываем n
        int n = in.nextInt();

        // создаем массив
        int[] a = new int[n];

        // определим максимальное значение
        int maxArr = 0;
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
            if (a[i] > maxArr) {
                maxArr = a[i];
            }
        }

        // создаем массив из чисел фибоначчи до m
        int[] f = fibGen(maxArr);

        // запомним, какие из a являются фибоначчи
        boolean[] boolFib = new boolean[n];
        for (int i = 0; i < n; i++) {
            boolFib[i] = fibCheck(a[i], f);
        }

        // считаем сколько чисел фибоначчи
        int fibCount = 0;
        for (boolean y : boolFib) {
            if (y) fibCount++;
        }

        // создаем два массива: для фибоначчи и для остальных
        int[] aFib = new int[fibCount];
        int[] aOth = new int[n - fibCount];

        int aFibIndex = 0;  // индекс для фибоначчи
        int aOthIndex = 0;  // индекс для остальных
        for (int i = 0; i < n; i++) {
            if (boolFib[i]) {
                aFib[aFibIndex++] = a[i];
            } else {
                aOth[aOthIndex++] = a[i];
            }
        }

        // сортируем числа фибоначчи по возрастанию, а остальные по убыванию
        bublMax(aFib);
        bublMin(aOth);

        // собираем в изначальный массив
        int p = 0;
        for (int i : aFib) {
            a[p++] = i;
        }
        for (int i : aOth) {
            a[p++] = i;
        }

        // выводим результат
        for (int x : a) {
            out.print(x + " ");
        }
        out.println();
        out.println(fibCount);
        // выводим, заменяя фибоначчи на индекс, остальное на -1
        for (int x : a) {
            int idx = getIndex(x, f);
            if (idx != -1) {
                out.print(idx + " ");
            } else {
                out.print(-1 + " ");
            }
        }
        out.println();
        // заменяем каждое число на сумму чётных цифр
        for (int i = 0; i < n; i++) {
            a[i] = evenCount(a[i]);
        }

        // выводим результат
        for (int x : a) {
            out.print(x + " ");
        }
    }

    // генерим фибоначчи до max
    private static int[] fibGen(int x) {
        // если максимум меньше 1, вернем массив с одним значением
        if (x < 1) {
            return new int[]{0};
        }

        // начальные члены
        int f1 = 0, f2 = 1;

        // временный массив
        int[] tmp = new int[x + 2];
        int c = 0;
        tmp[c++] = f1;
        tmp[c++] = f2;

        // генерим пока не превысим x
        while (true) {
            int f3 = f1 + f2;
            if (f3 > x) break;
            tmp[c++] = f3;
            f1 = f2;
            f2 = f3;
        }

        // формируем итог
        int[] r = new int[c];
        for (int i = 0; i < c; i++) {
            r[i] = tmp[i];
        }
        return r;
    }

    // проверяем, является ли число фибоначчи
    private static boolean fibCheck(int x, int[] f) {
        for (int y : f) {
            if (y == x) {
                return true;
            }
            if (y > x) {
                return false;
            }
        }
        return false;
    }

    // пузырьковая сортировка по возрастанию
    private static void bublMax(int[] q) {
        for (int i = 0; i < q.length - 1; i++) {
            for (int j = 0; j < q.length - 1 - i; j++) {
                if (q[j] > q[j + 1]) {
                    int tmp = q[j];
                    q[j] = q[j + 1];
                    q[j + 1] = tmp;
                }
            }
        }
    }

    // пузырьковая сортировка по убыванию
    private static void bublMin(int[] q) {
        for (int i = 0; i < q.length - 1; i++) {
            for (int j = 0; j < q.length - 1 - i; j++) {
                if (q[j] < q[j + 1]) {
                    int tmp = q[j];
                    q[j] = q[j + 1];
                    q[j + 1] = tmp;
                }
            }
        }
    }
    // получаем индекс числа в ряду фибоначчи
    private static int getIndex(int x, int[] f) {
        for (int i = 0; i < f.length; i++) {
            if (f[i] == x) {
                return i;
            }
            if (f[i] > x) {
                return -1;
            }
        }
        return -1;
    }
    //считаем сумму четных цифр
    private static int evenCount(int x) {
        int sum = 0;
        // пока число не закончилось
        while (x > 0) {
            int d = x % 10;
            if (d % 2 == 0) {
                sum += d;
            }
            x /= 10;
        }
        return sum;
    }
}
```

### 6. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на `X > Y > 0`:

    - **Input**:
        ```
        5 1.3
        ```

    - **Output**:
        ```
        5
        ```

2. Тест на `X < Y < 0`:

    - **Input**:
        ```
        -4 -2.2
        ```

    - **Output**:
        ```
        2.2
        ```

3. Тест на `X < 0 < Y`:

    - **Input**:
        ```
        -4 5
        ```

    - **Output**:
        ```
        5
        ```

4. Тест на `X = 0` или `Y = 0`:

    - **Input**:
        ```
        0 -3
        ```

    - **Output**:
        ```
        3
        ```

5. Тест на ограничение задачи:

    - **Input**:
        ```
        -1000000000 1000000000
        ```

    - **Output**:
        ```
        1000000000
        ```
